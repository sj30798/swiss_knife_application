// Generated from Apache PDFBox library which is licensed under the Apache License 2.0.
// The following copyright from the original authors applies.
//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../../../../../_init.dart";

/// from: org.apache.pdfbox.pdmodel.common.PDRange
///
/// This class will be used to signify a range.  a(min) &lt;= a* &lt;= a(max)
///@author Ben Litchfield
class PDRange extends jni.JObject {
  @override
  late final jni.JObjType<PDRange> $type = type;

  PDRange.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $PDRangeType();
  static final _new0 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("PDRange__new0")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructor with an initial range of 0..1.
  factory PDRange() {
    return PDRange.fromRef(_new0().object);
  }

  static final _new1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDRange__new1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(org.apache.pdfbox.cos.COSArray range)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructor assumes a starting index of 0.
  ///@param range The array that describes the range.
  factory PDRange.new1(
    jni.JObject range,
  ) {
    return PDRange.fromRef(_new1(range.reference).object);
  }

  static final _new2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("PDRange__new2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(org.apache.pdfbox.cos.COSArray range, int index)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructor with an index into an array.  Because some arrays specify
  /// multiple ranges ie [ 0,1,  0,2,  2,3 ] It is convenient for this
  /// class to take an index into an array.  So if you want this range to
  /// represent 0,2 in the above example then you would say <code>new PDRange( array, 1 )</code>.
  ///@param range The array that describes the index
  ///@param index The range index into the array for the start of the range.
  factory PDRange.new2(
    jni.JObject range,
    int index,
  ) {
    return PDRange.fromRef(_new2(range.reference, index).object);
  }

  static final _getCOSObject = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDRange__getCOSObject")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.cos.COSBase getCOSObject()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Convert this standard java object to a COS object.
  ///@return The cos object that matches this Java object.
  jni.JObject getCOSObject() {
    return const jni.JObjectType().fromRef(_getCOSObject(reference).object);
  }

  static final _getCOSArray = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDRange__getCOSArray")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.cos.COSArray getCOSArray()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the underlying array value.
  ///@return The cos object that this object wraps.
  jni.JObject getCOSArray() {
    return const jni.JObjectType().fromRef(_getCOSArray(reference).object);
  }

  static final _getMin = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDRange__getMin")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getMin()
  ///
  /// This will get the minimum value of the range.
  ///@return The min value.
  double getMin() {
    return _getMin(reference).float;
  }

  static final _setMin = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Float)>>("PDRange__setMin")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setMin(float min)
  ///
  /// This will set the minimum value for the range.
  ///@param min The new minimum for the range.
  void setMin(
    double min,
  ) {
    return _setMin(reference, min).check();
  }

  static final _getMax = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDRange__getMax")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getMax()
  ///
  /// This will get the maximum value of the range.
  ///@return The max value.
  double getMax() {
    return _getMax(reference).float;
  }

  static final _setMax = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Float)>>("PDRange__setMax")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setMax(float max)
  ///
  /// This will set the maximum value for the range.
  ///@param max The new maximum for the range.
  void setMax(
    double max,
  ) {
    return _setMax(reference, max).check();
  }

  static final _toString1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDRange__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// {@inheritDoc}
  jni.JString toString1() {
    return const jni.JStringType().fromRef(_toString1(reference).object);
  }
}

final class $PDRangeType extends jni.JObjType<PDRange> {
  const $PDRangeType();

  @override
  String get signature => r"Lorg/apache/pdfbox/pdmodel/common/PDRange;";

  @override
  PDRange fromRef(jni.JObjectPtr ref) => PDRange.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PDRangeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PDRangeType) && other is $PDRangeType;
  }
}
