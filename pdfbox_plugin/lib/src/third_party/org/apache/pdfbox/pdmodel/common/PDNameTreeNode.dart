// Generated from Apache PDFBox library which is licensed under the Apache License 2.0.
// The following copyright from the original authors applies.
//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../../../../../_init.dart";

/// from: org.apache.pdfbox.pdmodel.common.PDNameTreeNode
///
/// This class represents a node in a name tree.
///@author Ben Litchfield
///@param <T> The type of the values in this name tree.
class PDNameTreeNode<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<PDNameTreeNode<$T>> $type = type(T);

  final jni.JObjType<$T> T;

  PDNameTreeNode.fromRef(
    this.T,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $PDNameTreeNodeType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $PDNameTreeNodeType(
      T,
    );
  }

  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "PDNameTreeNode__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: protected void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructor.
  factory PDNameTreeNode({
    required jni.JObjType<$T> T,
  }) {
    return PDNameTreeNode.fromRef(T, _new0().object);
  }

  static final _new1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDNameTreeNode__new1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void <init>(org.apache.pdfbox.cos.COSDictionary dict)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructor.
  ///@param dict The dictionary that holds the name information.
  factory PDNameTreeNode.new1(
    jni.JObject dict, {
    required jni.JObjType<$T> T,
  }) {
    return PDNameTreeNode.fromRef(T, _new1(dict.reference).object);
  }

  static final _getCOSObject = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDNameTreeNode__getCOSObject")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.cos.COSDictionary getCOSObject()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Convert this standard java object to a COS object.
  ///@return The cos object that matches this Java object.
  jni.JObject getCOSObject() {
    return const jni.JObjectType().fromRef(_getCOSObject(reference).object);
  }

  static final _getParent = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDNameTreeNode__getParent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.common.PDNameTreeNode<T> getParent()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the parent node.
  ///@return parent node
  PDNameTreeNode<$T> getParent() {
    return $PDNameTreeNodeType(T).fromRef(_getParent(reference).object);
  }

  static final _setParent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDNameTreeNode__setParent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setParent(org.apache.pdfbox.pdmodel.common.PDNameTreeNode<T> parentNode)
  ///
  /// Sets the parent to the given node.
  ///@param parentNode the node to be set as parent
  void setParent(
    PDNameTreeNode<$T> parentNode,
  ) {
    return _setParent(reference, parentNode.reference).check();
  }

  static final _isRootNode = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDNameTreeNode__isRootNode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isRootNode()
  ///
  /// Determines if this is a root node or not.
  ///@return true if this is a root node
  bool isRootNode() {
    return _isRootNode(reference).boolean;
  }

  static final _getKids = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDNameTreeNode__getKids")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<org.apache.pdfbox.pdmodel.common.PDNameTreeNode<T>> getKids()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Return the children of this node.  This list will contain PDNameTreeNode objects.
  ///@return The list of children or null if there are no children.
  jni.JList<PDNameTreeNode<$T>> getKids() {
    return jni.JListType($PDNameTreeNodeType(T))
        .fromRef(_getKids(reference).object);
  }

  static final _setKids = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDNameTreeNode__setKids")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setKids(java.util.List<? extends org.apache.pdfbox.pdmodel.common.PDNameTreeNode<T>> kids)
  ///
  /// Set the children of this named tree.
  ///@param kids The children of this named tree. These have to be in sorted order. Because of
  /// that, it is usually easier to call \#setNames(Map) with a map and pass a single
  /// element list here.
  void setKids(
    jni.JList<jni.JObject> kids,
  ) {
    return _setKids(reference, kids.reference).check();
  }

  static final _getValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDNameTreeNode__getValue")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public T getValue(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The name to retrieve.
  ///@param name The name in the tree.
  ///@return The value of the name in the tree.
  ///@throws IOException If there is a problem creating the destinations.
  $T getValue(
    jni.JString name,
  ) {
    return T.fromRef(_getValue(reference, name.reference).object);
  }

  static final _getNames = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDNameTreeNode__getNames")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Map<java.lang.String,T> getNames()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will return a map of names on this level. The key will be a string,
  /// and the value will depend on where this class is being used.
  ///@return ordered map of COS objects or <code>null</code> if the dictionary
  /// contains no 'Names' entry on this level.
  ///@throws IOException If there is an error while creating the sub types.
  ///@see \#getKids()
  jni.JMap<jni.JString, $T> getNames() {
    return jni.JMapType(const jni.JStringType(), T)
        .fromRef(_getNames(reference).object);
  }

  static final _convertCOSToPD = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDNameTreeNode__convertCOSToPD")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected abstract T convertCOSToPD(org.apache.pdfbox.cos.COSBase base)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Method to convert the COS value in the name tree to the PD Model object. The
  /// default implementation will simply return the given COSBase object.
  /// Subclasses should do something specific.
  ///@param base The COS object to convert.
  ///@return The converted PD Model object.
  ///@throws IOException If there is an error during creation.
  $T convertCOSToPD(
    jni.JObject base,
  ) {
    return T.fromRef(_convertCOSToPD(reference, base.reference).object);
  }

  static final _createChildNode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDNameTreeNode__createChildNode")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected abstract org.apache.pdfbox.pdmodel.common.PDNameTreeNode<T> createChildNode(org.apache.pdfbox.cos.COSDictionary dic)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a child node object.
  ///@param dic The dictionary for the child node object to refer to.
  ///@return The new child node object.
  PDNameTreeNode<$T> createChildNode(
    jni.JObject dic,
  ) {
    return $PDNameTreeNodeType(T)
        .fromRef(_createChildNode(reference, dic.reference).object);
  }

  static final _setNames = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDNameTreeNode__setNames")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setNames(java.util.Map<java.lang.String,T> names)
  ///
  /// Set the names for this node. This method will set the appropriate upper and lower limits
  /// based on the keys in the map and take care of the ordering.
  ///@param names map of names to objects, or <code>null</code> for nothing.
  void setNames(
    jni.JMap<jni.JString, $T> names,
  ) {
    return _setNames(reference, names.reference).check();
  }

  static final _getUpperLimit = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDNameTreeNode__getUpperLimit")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getUpperLimit()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the highest value for a key in the name map.
  ///@return The highest value for a key in the map.
  jni.JString getUpperLimit() {
    return const jni.JStringType().fromRef(_getUpperLimit(reference).object);
  }

  static final _getLowerLimit = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDNameTreeNode__getLowerLimit")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLowerLimit()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the lowest value for a key in the name map.
  ///@return The lowest value for a key in the map.
  jni.JString getLowerLimit() {
    return const jni.JStringType().fromRef(_getLowerLimit(reference).object);
  }
}

final class $PDNameTreeNodeType<$T extends jni.JObject>
    extends jni.JObjType<PDNameTreeNode<$T>> {
  final jni.JObjType<$T> T;

  const $PDNameTreeNodeType(
    this.T,
  );

  @override
  String get signature => r"Lorg/apache/pdfbox/pdmodel/common/PDNameTreeNode;";

  @override
  PDNameTreeNode<$T> fromRef(jni.JObjectPtr ref) =>
      PDNameTreeNode.fromRef(T, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($PDNameTreeNodeType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PDNameTreeNodeType<$T>) &&
        other is $PDNameTreeNodeType<$T> &&
        T == other.T;
  }
}
