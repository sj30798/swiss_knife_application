// Generated from Apache PDFBox library which is licensed under the Apache License 2.0.
// The following copyright from the original authors applies.
//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../PDStream.dart" as pdstream_;

import "../PDRange.dart" as pdrange_;
import "../../../../../../_init.dart";

/// from: org.apache.pdfbox.pdmodel.common.function.PDFunction
///
/// This class represents a function in a PDF document.
///@author Ben Litchfield
class PDFunction extends jni.JObject {
  @override
  late final jni.JObjType<PDFunction> $type = type;

  PDFunction.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $PDFunctionType();
  static final _new0 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFunction__new0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(org.apache.pdfbox.cos.COSBase function)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructor.
  ///@param function The function stream.
  factory PDFunction(
    jni.JObject function,
  ) {
    return PDFunction.fromRef(_new0(function.reference).object);
  }

  static final _getFunctionType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFunction__getFunctionType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getFunctionType()
  ///
  /// Returns the function type.
  ///
  /// Possible values are:
  ///
  /// 0 - Sampled function
  /// 2 - Exponential interpolation function
  /// 3 - Stitching function
  /// 4 - PostScript calculator function
  ///@return the function type.
  int getFunctionType() {
    return _getFunctionType(reference).integer;
  }

  static final _getCOSObject = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFunction__getCOSObject")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.cos.COSDictionary getCOSObject()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the stream.
  ///@return The stream for this object.
  jni.JObject getCOSObject() {
    return const jni.JObjectType().fromRef(_getCOSObject(reference).object);
  }

  static final _getPDStream = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFunction__getPDStream")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected org.apache.pdfbox.pdmodel.common.PDStream getPDStream()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the underlying PDStream.
  ///@return The stream.
  pdstream_.PDStream getPDStream() {
    return const pdstream_.$PDStreamType()
        .fromRef(_getPDStream(reference).object);
  }

  static final _create = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFunction__create")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.common.function.PDFunction create(org.apache.pdfbox.cos.COSBase function)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create the correct PD Model function based on the COS base function.
  ///@param function The COS function dictionary.
  ///@return The PDModel Function object, never null.
  ///@throws IOException If we are unable to create the PDFunction object.
  static PDFunction create(
    jni.JObject function,
  ) {
    return const $PDFunctionType().fromRef(_create(function.reference).object);
  }

  static final _getNumberOfOutputParameters = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFunction__getNumberOfOutputParameters")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getNumberOfOutputParameters()
  ///
  /// This will get the number of output parameters that
  /// have a range specified.  A range for output parameters
  /// is optional so this may return zero for a function
  /// that does have output parameters, this will simply return the
  /// number that have the range specified.
  ///@return The number of output parameters that have a range
  /// specified.
  int getNumberOfOutputParameters() {
    return _getNumberOfOutputParameters(reference).integer;
  }

  static final _getRangeForOutput = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("PDFunction__getRangeForOutput")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public org.apache.pdfbox.pdmodel.common.PDRange getRangeForOutput(int n)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the range for a certain output parameters.  This is will never
  /// return null.  If it is not present then the range 0 to 0 will
  /// be returned.
  ///@param n The output parameter number to get the range for.
  ///@return The range for this component.
  pdrange_.PDRange getRangeForOutput(
    int n,
  ) {
    return const pdrange_.$PDRangeType()
        .fromRef(_getRangeForOutput(reference, n).object);
  }

  static final _setRangeValues = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFunction__setRangeValues")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setRangeValues(org.apache.pdfbox.cos.COSArray rangeValues)
  ///
  /// This will set the range values.
  ///@param rangeValues The new range values.
  void setRangeValues(
    jni.JObject rangeValues,
  ) {
    return _setRangeValues(reference, rangeValues.reference).check();
  }

  static final _getNumberOfInputParameters = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFunction__getNumberOfInputParameters")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getNumberOfInputParameters()
  ///
  /// This will get the number of input parameters that
  /// have a domain specified.
  ///@return The number of input parameters that have a domain
  /// specified.
  int getNumberOfInputParameters() {
    return _getNumberOfInputParameters(reference).integer;
  }

  static final _getDomainForInput = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("PDFunction__getDomainForInput")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public org.apache.pdfbox.pdmodel.common.PDRange getDomainForInput(int n)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the range for a certain input parameter.  This is will never
  /// return null.  If it is not present then the range 0 to 0 will
  /// be returned.
  ///@param n The parameter number to get the domain for.
  ///@return The domain range for this component.
  pdrange_.PDRange getDomainForInput(
    int n,
  ) {
    return const pdrange_.$PDRangeType()
        .fromRef(_getDomainForInput(reference, n).object);
  }

  static final _setDomainValues = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFunction__setDomainValues")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDomainValues(org.apache.pdfbox.cos.COSArray domainValues)
  ///
  /// This will set the domain values.
  ///@param domainValues The new domain values.
  void setDomainValues(
    jni.JObject domainValues,
  ) {
    return _setDomainValues(reference, domainValues.reference).check();
  }

  static final _eval = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFunction__eval")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.cos.COSArray eval(org.apache.pdfbox.cos.COSArray input)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// @param input The array of input values for the function.
  ///@return The of outputs the function returns based on those inputs.
  ///@throws IOException if something went wrong.
  ///@deprecated Replaced by \#eval(float[] input)
  jni.JObject eval(
    jni.JObject input,
  ) {
    return const jni.JObjectType()
        .fromRef(_eval(reference, input.reference).object);
  }

  static final _eval1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFunction__eval1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract float[] eval(float[] input)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Evaluates the function at the given input.
  /// ReturnValue = f(input)
  ///@param input The array of input values for the function.
  /// In many cases will be an array of a single value, but not always.
  ///@return The of outputs the function returns based on those inputs.
  /// In many cases will be an array of a single value, but not always.
  ///@throws IOException if something went wrong processing the function.
  jni.JArray<jni.jfloat> eval1(
    jni.JArray<jni.jfloat> input,
  ) {
    return const jni.JArrayType(jni.jfloatType())
        .fromRef(_eval1(reference, input.reference).object);
  }

  static final _getRangeValues = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFunction__getRangeValues")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected org.apache.pdfbox.cos.COSArray getRangeValues()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns all ranges for the output values as COSArray .
  /// Required for type 0 and type 4 functions
  ///@return the ranges array.
  jni.JObject getRangeValues() {
    return const jni.JObjectType().fromRef(_getRangeValues(reference).object);
  }

  static final _clipToRange = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFunction__clipToRange")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected float[] clipToRange(float[] inputValues)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Clip the given input values to the ranges.
  ///@param inputValues the input values
  ///@return the clipped values
  jni.JArray<jni.jfloat> clipToRange(
    jni.JArray<jni.jfloat> inputValues,
  ) {
    return const jni.JArrayType(jni.jfloatType())
        .fromRef(_clipToRange(reference, inputValues.reference).object);
  }

  static final _clipToRange1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Float,
                  ffi.Float, ffi.Float)>>("PDFunction__clipToRange1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, double, double, double)>();

  /// from: protected float clipToRange(float x, float rangeMin, float rangeMax)
  ///
  /// Clip the given input value to the given range.
  ///@param x the input value
  ///@param rangeMin the min value of the range
  ///@param rangeMax the max value of the range
  ///@return the clipped value
  double clipToRange1(
    double x,
    double rangeMin,
    double rangeMax,
  ) {
    return _clipToRange1(reference, x, rangeMin, rangeMax).float;
  }

  static final _interpolate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Float,
                  ffi.Float,
                  ffi.Float,
                  ffi.Float,
                  ffi.Float)>>("PDFunction__interpolate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, double, double, double, double, double)>();

  /// from: protected float interpolate(float x, float xRangeMin, float xRangeMax, float yRangeMin, float yRangeMax)
  ///
  /// For a given value of x, interpolate calculates the y value
  /// on the line defined by the two points (xRangeMin , xRangeMax )
  /// and (yRangeMin , yRangeMax ).
  ///@param x the to be interpolated value.
  ///@param xRangeMin the min value of the x range
  ///@param xRangeMax the max value of the x range
  ///@param yRangeMin the min value of the y range
  ///@param yRangeMax the max value of the y range
  ///@return the interpolated y value
  double interpolate(
    double x,
    double xRangeMin,
    double xRangeMax,
    double yRangeMin,
    double yRangeMax,
  ) {
    return _interpolate(
            reference, x, xRangeMin, xRangeMax, yRangeMin, yRangeMax)
        .float;
  }

  static final _toString1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFunction__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// {@inheritDoc}
  jni.JString toString1() {
    return const jni.JStringType().fromRef(_toString1(reference).object);
  }
}

final class $PDFunctionType extends jni.JObjType<PDFunction> {
  const $PDFunctionType();

  @override
  String get signature =>
      r"Lorg/apache/pdfbox/pdmodel/common/function/PDFunction;";

  @override
  PDFunction fromRef(jni.JObjectPtr ref) => PDFunction.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PDFunctionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PDFunctionType) && other is $PDFunctionType;
  }
}
